# Copyright 2013, Big Switch Networks, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

from collections import namedtuple, defaultdict
import loxi_globals
import struct
import template_utils
import loxi_utils.loxi_utils as utils
import util
import oftype
from loxi_ir import *

ofclasses_by_version = {}

PyOFClass = namedtuple('PyOFClass', ['name', 'pyname', 'members', 'type_members',
                                     'min_length', 'is_fixed_length',
                                     'has_internal_alignment', 'has_external_alignment'])

# Return the module and class names for the generated Python class
def generate_pyname(cls):
    if utils.class_is_action(cls):
        if cls == "of_action":
            return 'action', 'action'
        else:
            return 'action', cls[10:]
    elif utils.class_is_oxm(cls):
        if cls == 'of_oxm':
            return 'oxm', 'oxm'
        else:
            return 'oxm', cls[7:]
    elif utils.class_is_meter_band(cls):
        if cls == 'of_meter_band':
            return 'meter_band', 'meter_band'
        else:
            return 'meter_band', cls[14:]
    elif utils.class_is_instruction(cls):
        if cls == 'of_instruction':
            return 'instruction', 'instruction'
        else:
            return 'instruction', cls[15:]
    elif cls == 'of_header':
            return 'message', 'message'
    elif utils.class_is_message(cls):
        return 'message', cls[3:]
    else:
        return 'common', cls[3:]

# Create intermediate representation, extended from the LOXI IR
# HACK the oftype member attribute is replaced with an OFType instance
def build_ofclasses(version):
    ofclasses = []
    for ofclass in loxi_globals.ir[version].classes:
        cls = ofclass.name
        if ofclass.virtual:
            continue

        members = []
        type_members = []

        for m in ofclass.members:
            if type(m) == OFTypeMember:
                members.append(m)
                type_members.append(members[-1])
            elif type(m) == OFLengthMember:
                members.append(m)
            elif type(m) == OFFieldLengthMember:
                members.append(m)
            elif type(m) == OFPadMember:
                members.append(m)
            elif type(m) == OFDataMember:
                if utils.class_is_message(ofclass.name) and m.name == 'version':
                    # HACK move to frontend
                    members.append(OFTypeMember(
                        name=m.name,
                        oftype=m.oftype,
                        value=version.wire_version,
                        base_length=m.base_length,
                        is_fixed_length=m.is_fixed_length,
                        offset=m.offset))
                    type_members.append(members[-1])
                else:
                    members.append(m)

        ofclasses.append(
            PyOFClass(name=cls,
                      pyname=generate_pyname(cls)[1],
                      members=members,
                      type_members=type_members,
                      min_length=ofclass.base_length,
                      is_fixed_length=ofclass.is_fixed_length,
                      has_internal_alignment=cls == 'of_action_set_field',
                      has_external_alignment=cls == 'of_match_v3'))
    return ofclasses

def generate_init(out, name, version):
    util.render_template(out, 'init.py', version=version)

def generate_action(out, name, version):
    ofclasses = [x for x in ofclasses_by_version[version]
                 if utils.class_is_action(x.name)]
    util.render_template(out, 'action.py', ofclasses=ofclasses, version=version)

def generate_oxm(out, name, version):
    ofclasses = [x for x in ofclasses_by_version[version]
                 if utils.class_is_oxm(x.name)]
    util.render_template(out, 'oxm.py', ofclasses=ofclasses, version=version)

def generate_common(out, name, version):
    ofclasses = [x for x in ofclasses_by_version[version]
                 if not utils.class_is_message(x.name)
                    and not utils.class_is_action(x.name)
                    and not utils.class_is_instruction(x.name)
                    and not utils.class_is_meter_band(x.name)
                    and not utils.class_is_oxm(x.name)
                    and not utils.class_is_list(x.name)]
    util.render_template(out, 'common.py', ofclasses=ofclasses, version=version)

def generate_const(out, name, version):
    util.render_template(out, 'const.py', version=version,
                         enums=loxi_globals.ir[version].enums)

def generate_instruction(out, name, version):
    ofclasses = [x for x in ofclasses_by_version[version]
                 if utils.class_is_instruction(x.name)]
    util.render_template(out, 'instruction.py', ofclasses=ofclasses, version=version)

def generate_message(out, name, version):
    ofclasses = [x for x in ofclasses_by_version[version]
                 if utils.class_is_message(x.name)]
    util.render_template(out, 'message.py', ofclasses=ofclasses, version=version)

def generate_meter_band(out, name, version):
    ofclasses = [x for x in ofclasses_by_version[version]
                 if utils.class_is_meter_band(x.name)]
    util.render_template(out, 'meter_band.py', ofclasses=ofclasses, version=version)

def generate_pp(out, name, version):
    util.render_template(out, 'pp.py')

def generate_util(out, name, version):
    util.render_template(out, 'util.py', version=version)

Parser = namedtuple("Parser",
                    ["name",
                     "discriminator_offset",
                     "discriminator_length",
                     "children"])

# These should probably be removed from openflow_input
parser_blacklist = set([
    "of_experimenter_stats_header",
])

def generate_parser(out, name, version):
    def parser_name(ofclass):
        module_name, class_name = generate_pyname(ofclass.name)
        if ofclass.virtual:
            if module_name == class_name:
                return "parse_%s" % module_name
            else:
                return "parse_%s_%s" % (module_name, class_name)
        else:
            return "%s.%s.unpack" % (module_name, class_name)

    children = defaultdict(dict)
    for ofclass in loxi_globals.ir[version].classes:
        if ofclass.superclass:
            type_field_name = ofclass.superclass.discriminator.name
            type_value = ofclass.member_by_name(type_field_name).value
            children[ofclass.superclass.name][type_value] = parser_name(ofclass)

    parsers = []
    for ofclass in loxi_globals.ir[version].classes:
        if ofclass.virtual and ofclass.name not in parser_blacklist:
            parsers.append(Parser(
                name=parser_name(ofclass),
                discriminator_offset=ofclass.discriminator.offset,
                discriminator_length=ofclass.discriminator.length,
                children=children[ofclass.name]))

    util.render_template(out, 'parser.py', version=version, parsers=parsers)

def init():
    for version in loxi_globals.OFVersions.target_versions:
        ofclasses_by_version[version] = build_ofclasses(version)
